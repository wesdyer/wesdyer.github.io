
<!DOCTYPE html>
<html>
<head>
    <title>Geometry Unit Tests</title>
</head>
<body>
    <script src="../js/planner.js"></script>
    <script>
        const results = [];
        function assert(condition, message) {
            results.push({ passed: !!condition, message });
            if (!condition) console.error("FAIL:", message);
            else console.log("PASS:", message);
        }

        function runTests() {
            console.log("Running Geometry Tests...");

            // Test 1: Segment Intersection
            // Intersecting
            assert(Geom.segmentIntersect(
                {x:0, y:0}, {x:10, y:10},
                {x:0, y:10}, {x:10, y:0}
            ), "Cross segments should intersect");

            // Parallel/Non-intersecting
            assert(!Geom.segmentIntersect(
                {x:0, y:0}, {x:10, y:0},
                {x:0, y:5}, {x:10, y:5}
            ), "Parallel segments should not intersect");

            // Touching (End-to-End) - Should return false based on strict inequality in logic usually, let's verify behavior
            // Our implementation uses strict inequality > so touching usually returns false
            assert(!Geom.segmentIntersect(
                {x:0, y:0}, {x:5, y:0},
                {x:5, y:0}, {x:10, y:0}
            ), "Touching segments should not intersect (strict)");


            // Test 2: Point in Polygon
            const square = [{x:0, y:0}, {x:10, y:0}, {x:10, y:10}, {x:0, y:10}];
            assert(Geom.pointInPolygon({x:5, y:5}, square), "Point inside square");
            assert(!Geom.pointInPolygon({x:-5, y:5}, square), "Point outside square");

            // Concave Polygon (L-shape)
            const lShape = [
                {x:0, y:0}, {x:10, y:0}, {x:10, y:5}, {x:5, y:5}, {x:5, y:10}, {x:0, y:10}
            ];
            assert(Geom.pointInPolygon({x:2, y:8}, lShape), "Point inside L-shape vertical");
            assert(!Geom.pointInPolygon({x:8, y:8}, lShape), "Point in L-shape notch (outside)");


            // Test 3: Distance to Segment
            const segA = {x:0, y:0}, segB = {x:10, y:0};
            // On line
            assert(Math.abs(Geom.distToSegment({x:5, y:0}, segA, segB)) < 0.001, "Point on segment distance ~ 0");
            // Above
            assert(Math.abs(Geom.distToSegment({x:5, y:5}, segA, segB) - 5) < 0.001, "Point above segment distance = 5");
            // Past endpoint (should be distance to endpoint)
            // Point (-5, 0). Dist to (0,0) is 5.
            assert(Math.abs(Geom.distToSegment({x:-5, y:0}, segA, segB) - 5) < 0.001, "Point past segment start distance = 5");


            // Test 4: Segment Intersects Poly
            // Cutting through
            assert(Geom.segmentIntersectsPoly({x:-5, y:5}, {x:15, y:5}, square), "Segment cutting through square");
            // Fully inside
            assert(Geom.segmentIntersectsPoly({x:2, y:2}, {x:8, y:8}, square), "Segment fully inside square");
            // Fully outside
            assert(!Geom.segmentIntersectsPoly({x:-5, y:5}, {x:-2, y:5}, square), "Segment outside square");
            // Grazing (touching edge) - Depending on precision/implementation
            // If segment is part of edge?
            // Our logic checks strict intersection.
            // But midpoint check handles "Inside". Midpoint of edge is on boundary.
            // Ray casting for point on boundary is edge case.
            // We rely on "Clearance" (inflation) so exact edge grazing is technically unsafe if we want buffer.
            // But strict boolean check:
            assert(!Geom.segmentIntersectsPoly({x:0, y:-1}, {x:10, y:-1}, square), "Segment parallel near square");

            // Print Summary
            const failed = results.filter(r => !r.passed).length;
            console.log(`Tests Complete. ${results.length} run, ${failed} failed.`);
            window.testResults = { total: results.length, failed, results };
        }

        runTests();
    </script>
</body>
</html>
